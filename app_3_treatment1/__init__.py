from otree.api import *
import random

# Defines constants for the app
class C(BaseConstants):
    # Sets the app's URL name
    NAME_IN_URL = 'app_3_treatment1'
    # Disables automatic grouping
    PLAYERS_PER_GROUP = None
    # Sets the maximum number of rounds
    NUM_ROUNDS = 20
    # Sets the number of voters
    VOTERS_PER_GROUP = 3
    # Sets the representative's fixed salary per round
    REP_SALARY = 250
    # Sets the cost for Stage 2 actions
    STAGE_2_COST = 50
    # Sets the value of one point for a voter
    VOTER_SUCCESS_PAYOFF = 5
    # Sets the value of one point for a representative
    REP_SUCCESS_PAYOFF = 50
    # Sets the number of rounds a representative serves
    TERM_LENGTH = 3
    # Sets the round number to start checking for random game end
    START_OF_INDEFINITE_HORIZON = 7
    # Sets the probability the game continues each round
    CONTINUATION_PROB = 0.80

# Defines subsession-level properties
class Subsession(BaseSubsession):
    pass

# Function that runs at the beginning of each round
def creating_session(subsession: Subsession):
    # Gets the session-wide variables
    session = subsession.session
    # Checks if it is the first round
    if subsession.round_number == 1:
        # Gets all players in the session
        players = subsession.get_players()
        # Randomizes the order of players
        random.shuffle(players)
        # Selects the first N players to be voters
        voter_players = players[:C.VOTERS_PER_GROUP]
        # Stores the permanent IDs of voters
        session.vars['voter_pids'] = [p.participant.id for p in voter_players]
        # Selects the remaining players for the representative pool
        rep_pool_players = players[C.VOTERS_PER_GROUP:]
        # Stores the permanent IDs of the pool
        session.vars['rep_pool_pids'] = [p.participant.id for p in rep_pool_players]
        # Initializes the game over flag
        session.vars['game_over'] = False
        # Initializes the reason for the game ending
        session.vars['game_over_reason'] = ""
        # Initializes a list to store information about removed reps
        session.vars['removed_reps_info'] = []
        # Initializes the round counter for the current rep's term
        session.vars['term_round'] = 0
        # Checks if there are representatives in the pool
        if session.vars['rep_pool_pids']:
            # Promotes the first person from the pool to be the representative
            session.vars['current_rep_pid'] = session.vars['rep_pool_pids'].pop(0)
            # Starts their term counter
            session.vars['term_round'] = 1
        else:
            # Ends the game if the pool is empty
            session.vars['game_over'] = True
            session.vars['game_over_reason'] = "Not enough players for a Representative."

    # Gets the permanent lists of player IDs
    voter_pids = session.vars['voter_pids']
    current_rep_pid = session.vars.get('current_rep_pid')
    # Loops through each player for the current round
    for p in subsession.get_players():
        # Gets the player's permanent ID
        pid = p.participant.id
        # Assigns the 'Voter' role
        if pid in voter_pids:
            p.game_role = "Voter"
            p.is_representative = False
        # Assigns the 'Representative' role
        elif pid == current_rep_pid:
            p.game_role = "Representative"
            p.is_representative = True
        # Assigns the 'Inactive' role
        else:
            p.game_role = "Inactive"
            p.is_representative = False
    
    # Creates a list of active players for this round
    active_group = [p for p in subsession.get_players() if p.game_role in ["Voter", "Representative"]]
    # Creates a list of inactive players
    inactive_players = [p for p in subsession.get_players() if p.game_role == "Inactive"]
    # Initializes the grouping structure
    group_matrix = []
    # Puts all active players into one group
    if active_group: group_matrix.append(active_group)
    # Puts each inactive player into their own group of one
    for p in inactive_players: group_matrix.append([p])
    # Sets the group structure for the round
    subsession.set_group_matrix(group_matrix)

# Defines group-level properties
class Group(BaseGroup):
    # Stores the number of votes to remove the rep
    num_remove_votes = models.IntegerField(initial=0)
    # Stores the total value generated by the group in a round
    collective_pot = models.FloatField(initial=0)

# Defines player-level properties
class Player(BasePlayer):
    # Stores if the player is the representative
    is_representative = models.BooleanField()
    # Stores the player's role for the round
    game_role = models.StringField()
    # Stores the player's score from the slider task
    slider_score = models.IntegerField(initial=0)
    # Stores the voter's decision
    vote_to_remove = models.BooleanField(choices=[[True, 'Vote to Remove'], [False, 'Vote to Retain']], widget=widgets.RadioSelect)
    # Stores if the representative was removed
    was_removed = models.BooleanField(initial=False)
    # Stores the reason for the representative's removal
    removal_mechanism = models.StringField()
    # Stores the removed representative's legacy decision
    stage2_decision = models.IntegerField(widget=widgets.RadioSelect, choices=[[1, 'Sabotage'], [2, 'Help'], [0, 'Neutral']])

# Function to get a list of voters from a group
def get_voters(group: Group): return [p for p in group.get_players() if p.game_role == 'Voter']
# Function to get the representative from a group
def get_representative(group: Group):
    for p in group.get_players():
        if p.game_role == 'Representative': return p
    return None

# Defines the 'Introduction' page
class Introduction(Page):
    # Determines if the page is shown to a player
    @staticmethod
    def is_displayed(player: Player): return player.round_number == 1

# Defines the 'PoolWaitPage'
class PoolWaitPage(Page):
    # Determines if the page is shown to a player
    @staticmethod
    def is_displayed(player: Player): return not player.session.vars['game_over'] and player.game_role == "Inactive"

# Defines the 'SliderTask' page
class SliderTask(Page):
    # Binds the page to the Player model
    form_model = 'player'
    # Specifies which player field is a form field on this page
    form_fields = ['slider_score']
    # Sets the time limit for the page
    @staticmethod
    def get_timeout_seconds(player: Player): return player.session.config.get('slider_timeout', 60)
    # Determines if the page is shown to a player
    @staticmethod
    def is_displayed(player: Player): return not player.session.vars['game_over'] and player.game_role in ["Voter", "Representative"]

# Defines the 'ResultsWaitPage'
class ResultsWaitPage(WaitPage):
    # Function that runs after all players in a group arrive
    @staticmethod
    def after_all_players_arrive(group: Group):
        # Checks if there is a representative in the group
        if not get_representative(group): return
        # Gets the representative and voters
        rep, voters = get_representative(group), get_voters(group)
        # Calculates the total value generated
        pot = (rep.slider_score * C.REP_SUCCESS_PAYOFF + sum(p.slider_score for p in voters) * C.VOTER_SUCCESS_PAYOFF)
        # Stores the total value on the group
        group.collective_pot = pot
        # Calculates the payoff for each voter
        for p in voters: p.payoff = pot / C.VOTERS_PER_GROUP
        # Sets the representative's payoff
        rep.payoff = C.REP_SALARY

# Defines the 'Vote' page
class Vote(Page):
    # Determines if the page is shown to a player
    @staticmethod
    def is_displayed(player: Player): return False

# Defines the 'VoteWaitPage'
class VoteWaitPage(WaitPage):
    # Function that runs after all players in a group arrive
    @staticmethod
    def after_all_players_arrive(group: Group):
        # Checks if there is a representative in the group
        if not get_representative(group): return
        # Gets session variables and the representative
        session, rep = group.session, get_representative(group)
        # Checks if the representative's term is over
        if session.vars['term_round'] >= C.TERM_LENGTH:
            # Marks the representative as removed
            rep.was_removed = True
            # Records the reason for removal
            rep.removal_mechanism = 'no_vote_term_limit'
            # Stores information about the removed rep
            session.vars['removed_reps_info'].append({'participant_id': rep.participant.id, 'mechanism': 'no_vote_term_limit'})
            # Checks if there are more representatives in the pool
            if session.vars['rep_pool_pids']:
                # Promotes the next representative
                session.vars['current_rep_pid'] = session.vars['rep_pool_pids'].pop(0)
                # Resets the term counter
                session.vars['term_round'] = 1
            else:
                # Ends the game if the pool is empty
                session.vars['game_over'] = True; session.vars['game_over_reason'] = "Pool empty."
        else:
            # Increments the term counter if the term is not over
            session.vars['term_round'] += 1

# Defines the 'RoundResults' page
class RoundResults(Page):
    # Determines if the page is shown to a player
    @staticmethod
    def is_displayed(player: Player): return not player.session.vars['game_over'] and player.game_role in ["Voter", "Representative"]
    # Passes variables to the HTML template
    @staticmethod
    def vars_for_template(player: Player):
        # Gets the representative for the group
        rep = get_representative(player.group)
        # Passes performance data to the template
        return {'my_score': player.slider_score, 'collective_pot': player.group.collective_pot, 'representative_score': rep.slider_score if rep else 0}

# Defines the 'EndOfRoundWaitPage'
class EndOfRoundWaitPage(WaitPage):
    # Waits for all players in the session
    wait_for_all_groups = True
    # Function that runs after all players arrive
    @staticmethod
    def after_all_players_arrive(subsession: Subsession):
        # Gets session variables
        session = subsession.session
        # Checks if the game is already over
        if session.vars['game_over']: return
        # Checks for random game end condition
        if subsession.round_number >= C.START_OF_INDEFINITE_HORIZON and random.random() > C.CONTINUATION_PROB:
            session.vars['game_over'] = True; session.vars['game_over_reason'] = "The game ended randomly."
        # Checks if the maximum number of rounds has been reached
        if subsession.round_number >= C.NUM_ROUNDS:
            session.vars['game_over'] = True; session.vars['game_over_reason'] = "Max rounds reached."

# Defines the 'Stage2Decision' page
class Stage2Decision(Page):
    # Binds the page to the Player model
    form_model = 'player'
    # Specifies which player field is a form field on this page
    form_fields = ['stage2_decision']
    # Determines if the page is shown to a player
    @staticmethod
    def is_displayed(player: Player):
        # Checks if the game is over
        if not player.session.vars['game_over']: return False
        # Finds if this player was removed and for what reason
        my_removal_info = next((info for info in player.session.vars['removed_reps_info'] if info['participant_id'] == player.participant.id), None)
        # Does not show the page if the player was not a removed rep
        if not my_removal_info: return False
        # Shows the page only if they were removed by term limit
        return my_removal_info['mechanism'] == 'no_vote_term_limit'
    # Function that runs before the player leaves the page
    @staticmethod
    def before_next_page(player: Player, timeout_happened):
        # Applies the cost for Sabotage or Help actions
        if player.stage2_decision in [1, 2]: player.payoff -= C.STAGE_2_COST

# Defines the 'FinalResults' page
class FinalResults(Page):
    # Determines if the page is shown to a player
    @staticmethod
    def is_displayed(player: Player): return player.session.vars['game_over']
    # Passes variables to the HTML template
    @staticmethod
    def vars_for_template(player: Player):
        # Passes the reason for the game ending to the template
        return {'reason': player.session.vars.get('game_over_reason', 'The experiment has concluded.')}

# Defines the order of pages in the app
page_sequence = [Introduction, PoolWaitPage, SliderTask, ResultsWaitPage, Vote, VoteWaitPage, RoundResults, EndOfRoundWaitPage, Stage2Decision, FinalResults]